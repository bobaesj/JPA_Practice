# JPA(Java Persistence API) DevNote

## 📌EntityManager

JPA에서 제공하는 핵심 **인터페이스**로, 데이터베이스와 애플리케이션 간의 **상호작용을 관리하는 역할**을 합니다. 쉽게 말해, EntityManager는 JPA에서 **데이터베이스 작업을 수행하기 위해 사용되는 객체**이다.

@PersistenceContext

private EntityManager em;

em.persist() 

- 영속성 컨텍스트에 객체를 등록하여 관리하도록 한다.
- 이 단계에서 DB에 저장되는 것이 아니고 트랜잭션이 커밋되거나 flush()가 호출될때 반영된다.

em.flush()

- 영속 컨텍스트는 캐싱된 상태로 변경 사항을 관리하는데, flush()를 호출해 SQL을 강제로 실행시켜 DB에 동기화한다.
- 트랜잭션은 종료되지 않는다.

em.clear()

- 영속성 컨텍스트를 초기화한다.
- 관리 중이던 모든 영속 상태의 엔티티를 분리해, JPA가 엔티티들을 관리하지 않게 한다.
- 사용 목적: 메모리 절약과 영속성 컨텍스트에 남아있는 이전 상태를 제거하고 새로운 작업을 수행하기 위함이다.

## 📌Persistence Context(영속성 컨텍스트)

JPA에서 메모리 역할을 하는 공간으로, 엔티티를 관리하며서 해당 객체를 데이터베이스와 동기화하는 작업을 한다.

## 📌Transaction(트랜잭션)

데이터베이스 작업의 일관성(Consistency)과 무결성(Integrity)을 보장하기 위해 관련된 작업들을 하나의 논리적 단위로 묶는 개념이다. JPA에서 트랜잭션은 엔티티에 대한 데이터 변경작업(CRUD)이 데이터베이스에 반영되거나 취소(Rollback)되는 과정을 제어한다.

트랜잭션은 일반적으로 ACID 원칙에 따라 작동한다.

- A (Atomicity): 작업들이 모두 성공하거나 모두 실패해야 한다.
- C (Consistency): 트랜잭션 완료 후 데이터의 무결성이 보장된다.
- I (Isolation): 각 트랜잭션은 서로 독립적으로 실행된다.
- D (Durability): 트랜잭션이 성공하면 결과가 영구적으로 반영된다.

## 📌Query Method(쿼리 메소드)

Spring Data JPA에서 제공하는 기능으로, 이름만으로도 데이터베이스 쿼리를 자동으로 생성 및 실행할 수 있는 메소드를 말한다.

이러한 메소드들은 이름을 기반으로 데이터베이스 CRUD작업을 처리할 수 있다.

## 📌@Modifying

Spring Data JPA에서 UPDATE, DELETE와 같은 데이터 변경 작업을 수행하는 쿼리를 사용할 때 붙이는 어노테이션이다

주로 @Query와 함께 사용되며, 데이터베이스 상태를 변경하는 네이티브 SQL문이나 JPQL문을 실행할때 필수적으로 선언해야한다.

## 📌Bulk Update(벌크 연산)

SPring Data JPA는 엔티티 값을 조회하거나 변경할 때, 기본적으로 JPA는 영속성 컨텍스트에서 현재상태를 관리한다.

하지만 벌크 연산(UPDATEM DELETE)은 영속성 컨텍스트를 거치지 않고 직접 데이터베이스에서 실행되기 때문에 영속성 컨텍스트의 상태와 데이터베이스의 실제 상태가 일치하지 않게 된다.

해결 방법

1. EntityManager의 clear() 호출

벌크 연산 후, 영속성 컨텍스트를 비워 새로 데이터를 조회하도록 한다

1. @Modifying의 clearAutomatically 사용

위 옵션을 추가하면, 벌크 연산이 끝난 후 영속성 컨텍스트를 자동으로 정리할 수 있다.

## 📌JPA 로딩 방식

1. LAZY(지연 로딩)
    
    연관된 엔티티를 사용하는 시점까지 데이터베이스 조회를 미룬다.
    
    여러 번의 추가 쿼리가 실행될 수 있다. 특히 N + 1 문제를 유발할 가능성이 크다.
    
2. EAGER(즉시 로딩)
    
    연관된 엔티티를 무조건 함께 가져온다.
    
    불필요한 경우에도 데이터를 가져오면서 자원을 낭비할 수 있다.
    
- N + 1 문제란?
    
    N + 1 문제는 JPA 또는 ORM을 사용할 때, 1개의 메인 엔티티를 조회한 후 그것과 연관된 N개의 하위 엔티티를 각각 추가로 조회하는 쿼리가 실행되는 문제를 말한다.
    
    → N + 1 문제를 해소하거나, 필요한 데이터를 효율적으로 조회하기 위해 Fetch Join(패치 조인)을 사용한다.
    

## 📌Fetch Join(패치 조인)

패치 조인은 JPA에서 엔티티와 연관된 데이터를 한 번의 쿼리로 함께 로드하기 위한 방법이다.

주로 연관된 데이터가 LAZY(지연 로딩)으로 설정되어 있더라도 연관된 데이터를 한 쿼리로 가져오는데 사용된다.

- 필요성?
    
    기본적으로 JPA에서 다중 엔티티 간 연관 관계를 조회할 때 지연 로딩이 설정되어 있으면 첫 번째 엔티티를 조회하는 쿼리와 이후 연관된 데이터를 조회하는 추가 쿼리가 실행된다. 이로 인해 N + 1 문제가 발생할 수 있다.
    

## 📌@EntityGraph

@EntityGraph는 JPA에서 연관된 엔티티를 함께 로드하기 위해 JPQL이나 HQL 대신 사용할 수 있는 어노테이션이다.

패치 조인과 유사하게 동작하지만, 필요한 연관 데이터를 더 선언적이고 직관적으로 명시할 수 있다는 장점이있다.
